The cache plugin adds Spring bean method call, page fragment, and taglib caching to Grails applications. You configure one or more caches in @Config.groovy@ using an implementation-specific DSL, and annotate methods (either in Spring beans (typically Grails services) or controllers) or taglib closures to be cached.

There are three annotations; [Cacheable|api:grails.plugin.cache.Cacheable], [CachePut|api:grails.plugin.cache.CachePut], and [CacheEvict|api:grails.plugin.cache.CacheEvict]. You use \@Cacheable to mark a method or taglib closure as one that should check the cache for a pre-existing result, or generate a new result and cache it. Use \@CachePut to mark a method or taglib closure as one that should always be evaluated and store its result in the cache regardless of existing cache values. And use \@CacheEvict to flush a cache (either fully or partially) to force the re-evaluation of previously cached results.

This 'core' cache plugin uses an in-memory implementation where the caches and cache manager are backed by a thread-safe @java.util.concurrent.ConcurrentMap@. This is fine for testing and possibly for low-traffic sites, but you should consider using one of the extension plugins if you need clustering, disk storage, persistence between restarts, and more configurability of features like time-to-live, maximum cache size, etc. Currently the extension plugins include [cache-ehcache|http://grails.org/plugin/cache-ehcache], [cache-redis|http://grails.org/plugin/cache-redis], and [cache-gemfire|http://grails.org/plugin/cache-gemfire].
