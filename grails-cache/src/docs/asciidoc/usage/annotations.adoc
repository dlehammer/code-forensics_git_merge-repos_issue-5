The link:api/grails/plugin/cache/Cacheable.html[Cacheable] and link:api/grails/plugin/cache/CacheEvict.html[CacheEvict] annotations provided by the plugin have counterparts with the same names provided by Spring. See the http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html[Spring documentation] for their usage and allowed syntax.


== Service method caching


Given this simple service, you can see that the `getMessage` method is configured to cache the results in the `"message"` cache. The `title` parameter will be used as the cache key; if there were multiple parameters they would be combined into the key, and you can always specify the key using the Spring SpEL support. The `save` method is configured as one that evicts elements from the cache. There is no need to clear the entire cache in this case; instead any previously cached item with the same `title` attribute will be replaced with the current `Message` instance.

[source,groovy]
----
package com.yourcompany

import grails.plugin.cache.CacheEvict
import grails.plugin.cache.Cacheable

class MessageService {

   @Cacheable('message', key='#title')
   Message getMessage(String title) {
      println 'Fetching message'
      Message.findByTitle(title)
   }

   @CachePut(value='message', key='#message.title')
   void save(Message message) {
      println "Saving message $message"
      message.save()
   }

   @CacheEvict(value='message', key='#message.title')
   void delete(Message message) {
      println "Deleting message $message"
      message.delete()
   }
}
----

Note that you could also use \`CacheEvict for the `save@ method, which would remove the old cached value but not cache the current value.

This service works with the `Message` domain class:

[source,groovy]
----
package com.yourcompany

class Message implements Serializable {

   private static final long serialVersionUID = 1

   String title
   String body

   String toString() {
      "$title: $body"
   }
}
----

Note that for in-memory cache implementations it's not required that the objects being cached implement `Serializable` but if you use an implementation that uses Java serialization (for example the Redis plugin, or the Ehcache plugin when you have configured clustered caching) you must implement `Serializable`.

To test this out, be sure to define a `"message"` cache in `Config.groovy` and save and retrieve `Message` instances using the service. There are `println` statements but you can also turn on SQL logging to watch the database access that's needed to retrieve instances that aren't cached yet, and you shouldn't see database access for cached values.


== Controller action caching

WARNING: Version 4 of the plugin does not yet support controller action caching!

== If you can't use annotations

Annotations aren't required, they're just the most convenient approach for configuration. If you like you can define caching semantics in `grails-app/conf/spring/resources.groovy` (or `resources.xml` if you like XML). This is also useful if you want to apply caching but can't edit the code to add annotations (for example if you have compiled classes in a jar).

This Spring BeanBuilder DSL code will configure the same behavior as the two annotations in the example service class:

[source,groovy]
----
beans = {

   xmlns cache: 'http://www.springframework.org/schema/cache'
   xmlns aop: 'http://www.springframework.org/schema/aop'

   cache.'advice'(id: 'messageServiceCacheAdvice',
                  'cache-manager': 'grailsCacheManager') {
      caching(cache: 'message') {
         cacheable(method: 'getMessage')
         'cache-evict'(method: 'save', key: '#message.title')
      }
   }

   // apply the cacheable behavior to MessageService
   aop.config {
      advisor('advice-ref': 'messageServiceCacheAdvice',
              pointcut: 'execution(* com.yourcompany.MessageService.*(..))')
   }
}
----
